package org.itmo;

import java.io.FileWriter;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicIntegerArray;
import java.util.stream.Stream;

class Graph {
    private final int V;
    private final ArrayList<Integer>[] adjList;

    Graph(int vertices) {
        this.V = vertices;
        adjList = new ArrayList[vertices];
        for (int i = 0; i < vertices; ++i) {
            adjList[i] = new ArrayList<>();
        }
    }

    void addEdge(int src, int dest) {
        if (!adjList[src].contains(dest)) {
            adjList[src].add(dest);
        }
    }

    void parallelBFS(int startVertex, int parallelism) {
        final boolean visited[] = new boolean[V];

        for (int i = 0; i < V; ++i) {
            visited[i] = false;
        }

        List<Integer> currFront = new ArrayList<>();
        currFront.add(startVertex);

        visited[0] = false;

        ExecutorService executor = Executors.newFixedThreadPool(parallelism);

        while (!currFront.isEmpty()) {
            List<Integer> nextFront = new ArrayList<>();
            splitToNJobs(currFront, parallelism).stream()
            .map(batch -> executor.submit(new ThreadJob(visited, batch, nextFront)))
            .forEach(future -> {
                try {
                    future.get();
                } catch (Exception e) {}
            });

            currFront = nextFront;
        }

    }

    private ArrayList<List<Integer>> splitToNJobs(List<Integer> list, int nworkers) {
        ArrayList<List<Integer>> result = new ArrayList<List<Integer>>();

        int batch = (list.size() + nworkers - 1) / nworkers;
        for (int i = 0; i < list.size(); i += batch) {
            result.add(list.subList(i, Integer.min(i + batch, list.size())));
        }

        return result;
    }

    private class ThreadJob implements Runnable {
        final boolean[] visited;
        final List<Integer> vertexesToProcess;
        final List<Integer> dst;
        ThreadJob(boolean vis[], List<Integer> batch, List<Integer> dest) {
            visited = vis;
            vertexesToProcess = batch;
            dst = dest;
        }

        public void run() {
            for (Integer fr : vertexesToProcess) {
                for (Integer to : adjList[fr]) {
                    if (!visited[to]) {
                        synchronized (this) {
                            if (!visited[to]) {
                                visited[to] = true;
                                dst.add(to);
                            }
                        }
                    }
                }
            }
        }
    }

    //Generated by ChatGPT
    void bfs(int startVertex) {
        boolean[] visited = new boolean[V];

        LinkedList<Integer> queue = new LinkedList<>();

        visited[startVertex] = true;
        queue.add(startVertex);

        while (!queue.isEmpty()) {
            startVertex = queue.poll();

            for (int n : adjList[startVertex]) {
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

}
